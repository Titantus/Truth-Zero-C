[
    {
        "module_id": "MOD_001",
        "simulation_name": "Final Systems Handshake",
        "description": "Compares actual invariant_angle of an element against the exact tetrahedral lock angle (arccos(-1/3)). Shows delta, percentage deviation, status, and eta_peak. Produces bar plot and CSV export.",
        "python_code": "import matplotlib.pyplot as plt\nimport pandas as pd\n\ndef final_systems_handshake(symbol, registry, save_csv=True):\n    if symbol not in registry:\n        print(f\"Element {symbol} not found.\")\n        return\n    \n    el = registry[symbol]\n    TETRA_EXACT = 109.47122063449069\n    theta_actual = el.get('invariant_angle', TETRA_EXACT)\n    eta_peak = el.get('eta_peak', 0.5)\n    \n    delta_deg = theta_actual - TETRA_EXACT\n    delta_pct = (delta_deg / TETRA_EXACT) * 100\n    \n    if abs(delta_deg) < 0.05:\n        status = 'Excellent alignment'\n        bar_color = '#00FF9F'\n    elif abs(delta_deg) < 0.5:\n        status = 'Good alignment'\n        bar_color = '#FFD700'\n    else:\n        status = 'Significant deviation'\n        bar_color = '#FF6B6B'\n    \n    print(f'\\n{symbol} Handshake')\n    print(f'  Ideal: {TETRA_EXACT:.8f}°')\n    print(f'  Actual: {theta_actual:.6f}°')\n    print(f'  Δ: {delta_deg:+.6f}°  ({delta_pct:+.4f} %)')\n    print(f'  Status: {status}')\n    print(f'  η_peak: {eta_peak:.3f}')\n    \n    fig, ax = plt.subplots(figsize=(6, 4))\n    ax.bar(['Ideal Lock', 'Actual'], [TETRA_EXACT, theta_actual],\n           color=['#00F2FF', bar_color], alpha=0.85)\n    ax.axhline(TETRA_EXACT, color='white', ls='--', alpha=0.5)\n    ax.set_ylabel('Angle (°)') \n    ax.set_title(f'Handshake – {symbol}')\n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        pd.DataFrame({\n            'Symbol': [symbol],\n            'Ideal': [TETRA_EXACT],\n            'Actual': [theta_actual],\n            'Delta_deg': [delta_deg],\n            'Delta_pct': [delta_pct],\n            'Eta_peak': [eta_peak],\n            'Status': [status]\n        }).to_csv(f'Handshake_{symbol}.csv', index=False)",
        "dependencies": ["matplotlib", "pandas"],
        "version": "1.0.1",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_002",
        "simulation_name": "C-Ladder Scaling Analysis",
        "description": "Plots canvas damping factors (exp(-κ r)) across distance scales using registry kappa values. Shows strong/weak/EM/gravity-like ranges.",
        "python_code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndef c_ladder_scaling_analysis(symbol, registry, full_registry, save_csv=True):\n    if symbol not in registry:\n        print(f'Element {symbol} not found.')\n        return\n    \n    cl = full_registry['c_ladder_scales']\n    kappa_c4 = cl['C4_strong']['kappa_inverse_m']\n    kappa_c3 = cl['C3_weak']['kappa_inverse_m']\n    kappa_c2 = cl['C2_em']['kappa_inverse_m']\n    kappa_c1 = cl['C1_gravity_like']['kappa_inverse_m']\n    \n    r = np.logspace(-16, 0, 400)\n    \n    def damp(k, r): return np.exp(-k * r) if k > 0 else np.ones_like(r)\n    \n    d4 = damp(kappa_c4, r)\n    d3 = damp(kappa_c3, r)\n    d2 = damp(kappa_c2, r)\n    d1 = damp(kappa_c1, r)\n    \n    fig, ax = plt.subplots(figsize=(9, 5))\n    ax.loglog(r, d4, '#FF00FF', lw=2, label='C4 – Strong')\n    ax.loglog(r, d3, '#00FFFF', lw=2, label='C3 – Weak')\n    ax.loglog(r, d2, '#FFFF00', lw=2, label='C2 – EM')\n    ax.loglog(r, d1, '#00FF7F', lw=2, label='C1 – Gravity')\n    ax.axvline(1e-15, color='0.7', ls=':', label='~1 fm')\n    ax.set_xlim(1e-16, 1)\n    ax.set_ylim(1e-5, 1.2)\n    ax.set_title(f'C-Ladder Damping – {symbol}')\n    ax.set_xlabel('Distance r (m)')\n    ax.set_ylabel('Damping factor')\n    ax.legend(framealpha=0.15)\n    ax.grid(alpha=0.2, which='both')\n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        pd.DataFrame({\n            'r_m': r,\n            'C4': d4,\n            'C3': d3,\n            'C2': d2,\n            'C1': d1\n        }).to_csv(f'CLadder_{symbol}.csv', index=False)",
        "dependencies": ["matplotlib", "numpy", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_003",
        "simulation_name": "Dual Sweep Visualizer",
        "description": "Plots two elements side-by-side or overlaid to visualize handshake compatibility, interference, or alignment difference between their invariant angles and efficiency curves.",
        "python_code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndef dual_sweep_visualizer(symbol_a, symbol_b, registry, save_csv=True):\n    if symbol_a not in registry or symbol_b not in registry:\n        print('One or both symbols not found in registry.')\n        return\n    \n    el_a = registry[symbol_a]\n    el_b = registry[symbol_b]\n    \n    TETRA_EXACT = 109.47122063449069\n    theta = np.linspace(108.0, 111.0, 1200)\n    \n    def gaussian_response(t, mu, sigma):\n        return np.exp( - (t - mu)**2 / (2 * sigma**2) )\n    \n    # Use element-specific or fallback values\n    mu_a = el_a.get('invariant_angle', TETRA_EXACT)\n    sigma_a = 0.10\n    resp_a = gaussian_response(theta, mu_a, sigma_a)\n    \n    mu_b = el_b.get('invariant_angle', TETRA_EXACT)\n    sigma_b = 0.10\n    resp_b = gaussian_response(theta, mu_b, sigma_b)\n    \n    interference = resp_a * resp_b   # simple multiplicative interference\n    \n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(9, 7), sharex=True)\n    \n    ax1.plot(theta, resp_a, color='#00F2FF', lw=2, label=f'{symbol_a} ({mu_a:.5f}°)')\n    ax1.plot(theta, resp_b, color='#FF00FF', lw=2, label=f'{symbol_b} ({mu_b:.5f}°)')\n    ax1.axvline(TETRA_EXACT, color='white', ls='--', alpha=0.5, label='Exact tetra')\n    ax1.set_title(f'Dual Response Curves')\n    ax1.set_ylabel('Response')\n    ax1.legend(framealpha=0.2)\n    ax1.grid(alpha=0.18)\n    \n    ax2.plot(theta, interference, color='lime', lw=2.5, label='Interference (A × B)')\n    ax2.axvline(TETRA_EXACT, color='white', ls='--', alpha=0.5)\n    ax2.set_title(f'Handshake Interference')\n    ax2.set_xlabel('Angle (°)') \n    ax2.set_ylabel('Combined Amplitude')\n    ax2.legend(framealpha=0.2)\n    ax2.grid(alpha=0.18)\n    \n    plt.suptitle(f'Dual Sweep: {symbol_a} vs {symbol_b}', fontsize=14)\n    plt.tight_layout(rect=[0, 0, 1, 0.96])\n    plt.show()\n    \n    if save_csv:\n        df = pd.DataFrame({\n            'theta': theta,\n            f'{symbol_a}_response': resp_a,\n            f'{symbol_b}_response': resp_b,\n            'interference': interference\n        })\n        df.to_csv(f'DualSweep_{symbol_a}_vs_{symbol_b}.csv', index=False)\n        print(f'Saved → DualSweep_{symbol_a}_vs_{symbol_b}.csv')",
        "dependencies": ["matplotlib", "numpy", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
   {
        "module_id": "MOD_004",
        "simulation_name": "Resonance Collapse Sequence",
        "description": "Simulates a simple time-domain collapse from wave optimum toward lock optimum under restoring torque. Shows trajectory and final stabilization angle.",
        "python_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef resonance_collapse_sequence(symbol, registry, steps=8000, dt=0.001, save_csv=True):\n    if symbol not in registry:\n        print(f'Element {symbol} not found.')\n        return\n    \n    el = registry[symbol]\n    TETRA_EXACT = 109.47122063449069\n    theta_wave = 109.33\n    \n    # Start near wave center with small noise\n    theta = theta_wave + np.random.normal(0, 0.04)\n    omega = 0.0  # angular velocity\n    history = [theta]\n    \n    k_lock = 45.0    # restoring strength toward tetra\n    k_wave = 18.0    # weaker attraction to wave center\n    \n    for _ in range(steps):\n        tau = -k_lock * (theta - TETRA_EXACT) - k_wave * (theta - theta_wave)\n        omega += tau * dt\n        theta += omega * dt\n        history.append(theta)\n    \n    final_theta = history[-1]\n    print(f'\\nResonance Collapse – {symbol}')\n    print(f'  Started near wave: {theta_wave:.5f}°')\n    print(f'  Final stabilized: {final_theta:.6f}°')\n    print(f'  Distance to lock: {abs(final_theta - TETRA_EXACT):.6f}°')\n    \n    fig, ax = plt.subplots(figsize=(10, 4.8))\n    ax.plot(history, color='#00FFAA', lw=1.4, alpha=0.9)\n    ax.axhline(TETRA_EXACT, color='white', ls='--', alpha=0.6, label=f'Exact tetra {TETRA_EXACT:.5f}°')\n    ax.axhline(theta_wave, color='#FF88FF', ls=':', label=f'Wave center {theta_wave:.5f}°')\n    ax.set_title(f'Resonance Collapse Trajectory – {symbol}')\n    ax.set_xlabel('Time step')\n    ax.set_ylabel('Angle (°)') \n    ax.legend(framealpha=0.2)\n    ax.grid(alpha=0.18)\n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df = pd.DataFrame({'step': range(len(history)), 'theta': history})\n        df.to_csv(f'Collapse_{symbol}.csv', index=False)\n        print(f'Saved → Collapse_{symbol}.csv')",
        "dependencies": ["matplotlib", "numpy", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_005",
        "simulation_name": "Wave-Lock Interference Potential",
        "description": "Generates superposition and interference potential between wave and lock Gaussians for a given element. Exports curve data to CSV.",
        "python_code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndef wave_lock_interference(symbol, registry, save_csv=True):\n    if symbol not in registry:\n        print(f'Element {symbol} not found.')\n        return\n    \n    TETRA_EXACT = 109.47122063449069\n    theta_wave = 109.33\n    sigma_wave = 0.12\n    sigma_lock = 0.085\n    \n    theta = np.linspace(108.5, 110.5, 2400)\n    \n    wave_pot = np.exp( - (theta - theta_wave)**2 / (2 * sigma_wave**2) )\n    lock_pot = np.exp( - (theta - TETRA_EXACT)**2 / (2 * sigma_lock**2) )\n    interference = wave_pot * lock_pot\n    \n    fig, ax = plt.subplots(figsize=(9.5, 5.2))\n    ax.plot(theta, wave_pot, color='#00CCFF', lw=1.8, alpha=0.7, label='Wave component')\n    ax.plot(theta, lock_pot, color='#FF44FF', lw=1.8, alpha=0.7, label='Lock component')\n    ax.plot(theta, interference, color='white', lw=2.8, label='Interference (product)')\n    ax.axvline(TETRA_EXACT, color='0.8', ls='--', alpha=0.5, label=f'Exact tetra {TETRA_EXACT:.5f}°')\n    ax.axvline(theta_wave, color='#FF88FF', ls=':', label=f'Wave {theta_wave:.5f}°')\n    ax.set_title(f'Wave-Lock Interference Potential – {symbol}')\n    ax.set_xlabel('Angle (°)') \n    ax.set_ylabel('Potential amplitude (a.u.)')\n    ax.legend(framealpha=0.15)\n    ax.grid(alpha=0.2)\n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df = pd.DataFrame({\n            'theta': theta,\n            'wave': wave_pot,\n            'lock': lock_pot,\n            'interference': interference\n        })\n        df.to_csv(f'WaveLock_Interference_{symbol}.csv', index=False)\n        print(f'Saved → WaveLock_Interference_{symbol}.csv')",
        "dependencies": ["matplotlib", "numpy", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_006",
        "simulation_name": "Torque Density vs Atomic Number Trend",
        "description": "Creates a line + scatter plot of torque_density_alpha across atomic numbers, highlighting trends and outliers. Includes logarithmic scaling option.",
        "python_code": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndef torque_density_trend(registry, log_scale=True, save_csv=True):\n    data = []\n    for sym, el in registry.items():\n        z = el.get('atomic_number', 0)\n        alpha = el.get('torque_density_alpha', 0.008)\n        eta = el.get('eta_peak', 0.5)\n        data.append({'Symbol': sym, 'Z': z, 'Alpha': alpha, 'Eta_peak': eta})\n    \n    df = pd.DataFrame(data).sort_values('Z')\n    \n    fig, ax = plt.subplots(figsize=(11, 5.5))\n    if log_scale:\n        ax.semilogy(df['Z'], df['Alpha'], 'o-', color='#00DDFF', lw=1.5, markersize=6, alpha=0.9)\n        ax.set_yscale('log')\n        ax.set_ylabel('Torque Density Alpha (log scale)')\n    else:\n        ax.plot(df['Z'], df['Alpha'], 'o-', color='#00DDFF', lw=1.5, markersize=6, alpha=0.9)\n        ax.set_ylabel('Torque Density Alpha')\n    \n    ax.set_title('Torque Density Trend Across Periodic Table')\n    ax.set_xlabel('Atomic Number Z')\n    ax.grid(alpha=0.2)\n    \n    # Label light/heavy extremes\n    for i, row in df[df['Z'].isin([1, 118])].iterrows():\n        ax.text(row['Z'] + 1.5, row['Alpha'], row['Symbol'], fontsize=9, color='white')\n    \n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df.to_csv('Torque_Density_Trend.csv', index=False)\n        print('Saved → Torque_Density_Trend.csv')\n    return df",
        "dependencies": ["matplotlib", "pandas", "numpy"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_007",
        "simulation_name": "Bounce Gap Stability Monte-Carlo",
        "description": "Runs Monte-Carlo trials varying sigma_wave, sigma_lock and tilt to test stability of the ~0.14° bounce gap. Produces histogram of fitted gaps.",
        "python_code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef bounce_gap_monte_carlo(n_trials=8000, save_csv=True):\n    TETRA_EXACT = 109.47122063449069\n    theta_wave_guess = 109.33\n    \n    gaps = []\n    for _ in range(n_trials):\n        sigma_w = np.random.uniform(0.09, 0.15)\n        sigma_l = np.random.uniform(0.07, 0.10)\n        amp_w   = np.random.uniform(0.8, 1.1)\n        tilt    = np.random.uniform(-0.01, 0.005)\n        \n        theta = np.linspace(108.8, 110.2, 1800)\n        wave = amp_w * np.exp( - (theta - theta_wave_guess)**2 / (2*sigma_w**2) )\n        lock = np.exp( - (theta - TETRA_EXACT)**2 / (2*sigma_l**2) )\n        y = wave + lock + tilt * (theta - 109.0)\n        \n        def dbl_g(x, a1,m1,s1, a2,m2,s2):\n            return a1*np.exp(-(x-m1)**2/(2*s1**2)) + a2*np.exp(-(x-m2)**2/(2*s2**2))\n        \n        try:\n            popt, _ = curve_fit(dbl_g, theta, y, p0=[1,109.33,0.12,1,109.47,0.085],\n                                bounds=([0.5,108,0.05,0.5,109,0.05], [2,110,0.3,2,110,0.3]))\n            mu1, mu2 = sorted([popt[1], popt[4]])\n            gap = mu2 - mu1\n            if 0.05 < gap < 0.25:\n                gaps.append(gap)\n        except:\n            pass\n    \n    if not gaps:\n        print('No valid fits obtained.')\n        return\n    \n    print(f'Mean gap: {np.mean(gaps):.5f} ± {np.std(gaps):.5f} °')\n    print(f'Median gap: {np.median(gaps):.5f} °')\n    print(f'Trials with gap ≈0.14°: {np.mean(np.abs(np.array(gaps)-0.141)<0.015):.3f}')\n    \n    plt.figure(figsize=(9,5))\n    plt.hist(gaps, bins=80, density=True, color='#44FF88', alpha=0.7, edgecolor='white')\n    plt.axvline(0.14122, color='red', ls='--', lw=2, label='Target gap 0.14122°')\n    plt.xlabel('Fitted bounce gap (°)') \n    plt.ylabel('Density')\n    plt.title('Bounce Gap Stability – Monte-Carlo')\n    plt.legend()\n    plt.grid(alpha=0.2)\n    plt.show()\n    \n    if save_csv:\n        pd.DataFrame({'gap': gaps}).to_csv('Bounce_Gap_MonteCarlo.csv', index=False)\n        print('Saved → Bounce_Gap_MonteCarlo.csv')",
        "dependencies": ["matplotlib", "numpy", "scipy", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_008",
        "simulation_name": "Element Angle Deviation Heatmap",
        "description": "Creates a heatmap showing deviation from exact tetrahedral angle across selected elements, colored by deviation magnitude.",
        "python_code": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\ndef angle_deviation_heatmap(registry, symbols=None, save_csv=True):\n    if symbols is None:\n        symbols = list(registry.keys())[:40]  # first 40 or customize\n    \n    TETRA_EXACT = 109.47122063449069\n    data = []\n    for sym in symbols:\n        if sym in registry:\n            angle = registry[sym].get('invariant_angle', TETRA_EXACT)\n            dev = angle - TETRA_EXACT\n            data.append({'Symbol': sym, 'Angle': angle, 'Deviation': dev})\n    \n    df = pd.DataFrame(data)\n    \n    fig, ax = plt.subplots(figsize=(12, len(symbols)*0.35 + 1.5))\n    colors = plt.cm.coolwarm((df['Deviation'] - df['Deviation'].min()) / \n                             (df['Deviation'].max() - df['Deviation'].min()))\n    bars = ax.barh(df['Symbol'], df['Deviation'], color=colors)\n    ax.axvline(0, color='white', ls='--', alpha=0.6)\n    ax.set_xlabel('Deviation from exact tetra (°)')\n    ax.set_title('Angle Deviation Heatmap')\n    ax.grid(alpha=0.18, axis='x')\n    \n    # Value labels\n    for bar, dev in zip(bars, df['Deviation']):\n        x = bar.get_width()\n        ax.text(x + 0.01 * np.sign(x), bar.get_y() + bar.get_height()/2,\n                f'{dev:+.4f}°', va='center', fontsize=9)\n    \n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df.to_csv('Angle_Deviation_Heatmap.csv', index=False)\n        print('Saved → Angle_Deviation_Heatmap.csv')\n    return df",
        "dependencies": ["matplotlib", "pandas", "numpy"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_009",
        "simulation_name": "Shake Frequency vs Invariant Angle Scatter",
        "description": "Scatter plot of shake_hz vs invariant_angle across elements. Point size by eta_peak, color by torque_density_alpha.",
        "python_code": "import matplotlib.pyplot as plt\nimport pandas as pd\n\ndef shake_freq_vs_angle(registry, save_csv=True):\n    data = []\n    for sym, el in registry.items():\n        f = el.get('shake_hz', 1e12)\n        angle = el.get('invariant_angle', 109.47122063449069)\n        eta = el.get('eta_peak', 0.5)\n        alpha = el.get('torque_density_alpha', 0.008)\n        data.append({'Symbol': sym, 'shake_hz': f, 'angle': angle, 'eta': eta, 'alpha': alpha})\n    \n    df = pd.DataFrame(data)\n    \n    fig, ax = plt.subplots(figsize=(11, 6))\n    scatter = ax.scatter(df['shake_hz'], df['angle'], s=df['eta']*400,\n                         c=df['alpha'], cmap='viridis', alpha=0.85, edgecolor='white')\n    plt.colorbar(scatter, label='Torque Density Alpha')\n    ax.set_xscale('log')\n    ax.set_title('Shake Frequency vs Invariant Angle\\n(size ∝ η_peak, color ∝ torque alpha)')\n    ax.set_xlabel('Shake Frequency (Hz) – log scale')\n    ax.set_ylabel('Invariant Angle (°)') \n    ax.grid(alpha=0.18)\n    \n    # Label light elements\n    for i, row in df[df['shake_hz'] < 1e14].iterrows():\n        ax.text(row['shake_hz']*1.2, row['angle'], row['Symbol'], fontsize=8, color='white')\n    \n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df.to_csv('Shake_vs_Angle_Scatter.csv', index=False)\n        print('Saved → Shake_vs_Angle_Scatter.csv')\n    return df",
        "dependencies": ["matplotlib", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_010",
        "simulation_name": "Master Periodic Table Generator",
        "description": "Creates scatter plot of torque_density_alpha vs atomic number Z. Point size ∝ eta_peak, color ∝ deviation from exact tetrahedral angle.",
        "python_code": "import matplotlib.pyplot as plt\nimport pandas as pd\n\ndef master_periodic_table_generator(registry, tetra_exact=109.47122063449069, save_csv=True):\n    data = []\n    for sym, el in registry.items():\n        z = el.get('atomic_number', 0)\n        alpha = el.get('torque_density_alpha', 0.008)\n        angle = el.get('invariant_angle', tetra_exact)\n        eta = el.get('eta_peak', 0.5)\n        dev = abs(angle - tetra_exact)\n        data.append({'Symbol': sym, 'Z': z, 'Alpha': alpha, 'Angle': angle, 'Deviation': dev, 'Eta_peak': eta})\n    \n    df = pd.DataFrame(data).sort_values('Z')\n    \n    fig, ax = plt.subplots(figsize=(13, 6))\n    scatter = ax.scatter(df['Z'], df['Alpha'], c=df['Deviation'], s=df['Eta_peak']*300,\n                         cmap='coolwarm', alpha=0.85, edgecolor='white', linewidth=0.4)\n    plt.colorbar(scatter, label='Deviation from exact tetra (°)')\n    ax.set_yscale('log')\n    ax.set_title('Torque Density vs Atomic Number\\n(size ∝ η_peak, color ∝ angle deviation)')\n    ax.set_xlabel('Atomic Number Z')\n    ax.set_ylabel('Torque Density Alpha (log)')\n    ax.grid(alpha=0.18)\n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df.to_csv('Master_Periodic_Audit.csv', index=False)\n    return df",
        "dependencies": ["matplotlib", "pandas"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_011",
        "simulation_name": "Falsifiability Stress Test (Lattice Integrity)",
        "description": "Performs a recursive sensitivity analysis on a list of elements. Calculates cumulative Phonon Risk based on invariant angle deviations. Flags highly incompatible combinations where thermal drag predicts structural collapse.",
        "python_code": "import itertools\nimport pandas as pd\n\ndef stress_test_lattice(element_list, registry, save_csv=True):\n    print(f'\\n--- Lattice Integrity Stress Test ---')\n    print(f'Testing combinations for: {element_list}')\n    \n    TETRA_EXACT = 109.47122063449069\n    results = []\n    \n    for pair in itertools.combinations(element_list, 2):\n        sym_a, sym_b = pair\n        if sym_a not in registry or sym_b not in registry:\n            continue\n            \n        el_a = registry[sym_a]\n        el_b = registry[sym_b]\n        \n        angle_a = el_a.get('invariant_angle', TETRA_EXACT)\n        angle_b = el_b.get('invariant_angle', TETRA_EXACT)\n        \n        delta = abs(angle_a - angle_b)\n        risk = min(100.0, delta * 12.0)\n        \n        if risk < 10:\n            status = 'Stable (Excellent alignment)'\n        elif risk < 50:\n            status = 'Metastable (Requires dampening)'\n        else:\n            status = 'HIGH INCOMPATIBILITY (Structural collapse predicted)'\n            \n        results.append({\n            'Element_A': sym_a,\n            'Element_B': sym_b,\n            'Delta_Theta': delta,\n            'Phonon_Risk_Pct': risk,\n            'Status': status\n        })\n        \n        print(f'\\n{sym_a} vs {sym_b}:')\n        print(f'  Δθ: {delta:.5f}°')\n        print(f'  Risk: {risk:.2f}% -> {status}')\n        \n    if save_csv and results:\n        df = pd.DataFrame(results)\n        df.to_csv('Lattice_Stress_Test.csv', index=False)\n        print('\\nSaved → Lattice_Stress_Test.csv')\n    \n    return results",
        "dependencies": ["pandas", "itertools"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    },
    {
        "module_id": "MOD_012",
        "simulation_name": "Priority Audit: Efficiency vs Angular Deviation",
        "description": "Plots Peak Efficiency (eta_peak) against absolute deviation from the exact tetrahedral angle. Sizes points by torque density alpha to identify active zones like the Siphon Pivot and Metal Lock Zone.",
        "python_code": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import pearsonr\n\ndef priority_audit_visualizer(registry, save_csv=True):\n    TETRA_EXACT = 109.47122063449069\n    rows = []\n    for sym, el in registry.items():\n        if 'invariant_angle' in el and 'eta_peak' in el:\n            dev = abs(el['invariant_angle'] - TETRA_EXACT)\n            rows.append({\n                'Symbol': sym,\n                'Deviation': dev,\n                'Eta_Peak': el['eta_peak'],\n                'Alpha': el.get('torque_density_alpha', 0.008)\n            })\n            \n    if not rows:\n        print('No valid data found in registry.')\n        return\n        \n    df = pd.DataFrame(rows)\n    r_val, p_val = pearsonr(df['Eta_Peak'], df['Deviation'])\n    \n    plt.style.use('dark_background')\n    fig, ax = plt.subplots(figsize=(10, 6))\n    \n    sizes = np.clip(df['Alpha'] * 1e8, 20, 500)\n    scatter = ax.scatter(df['Eta_Peak'], df['Deviation'],\n                         s=sizes, c=df['Alpha'], cmap='magma', alpha=0.8, edgecolors='white')\n                         \n    ax.set_title(f\\'T\\'Z0C Priority Audit: Efficiency vs Angular Deviation\\nPearson r: {r_val:.3f} | p-value: {p_val:.2e}\\')\n    ax.set_xlabel('Peak Efficiency (η_peak)')\n    ax.set_ylabel('Absolute Deviation from 109.47122° (Δθ)')\n    plt.colorbar(scatter, label='Torque Density (α)')\n    \n    ax.axhline(abs(45.1 - TETRA_EXACT), color='cyan', linestyle='--', alpha=0.5, label='Metal Lock Zone (~64° Δ)')\n    ax.axhline(abs(106.98 - TETRA_EXACT), color='lime', linestyle='--', alpha=0.5, label='Siphon Pivot (~2.5° Δ)')\n    \n    plt.legend()\n    plt.grid(color='white', alpha=0.1)\n    plt.tight_layout()\n    plt.show()\n    \n    if save_csv:\n        df.to_csv('Priority_Audit_Efficiency.csv', index=False)\n        print('\\nSaved → Priority_Audit_Efficiency.csv')\n        \n    return df",
        "dependencies": ["matplotlib", "pandas", "numpy", "scipy"],
        "version": "1.0.0",
        "last_updated": "2026-03-01"
    }
]